// cmd/series/series.go
package series

import (
	"encoding/json"
	"flag"
	"fmt"
	"mangaupdatescli/internal/apiclient"
	"mangaupdatescli/internal/utils"
	"net/http"
	"os"
	"sort"
	"strings"
)

// CommandHandler defines the function signature for command handlers
type CommandHandler func(args []string)

// CommandInfo stores the handler and its associated (generated) help content
type CommandInfo struct {
	Handler CommandHandler
	Help    utils.HelpContent
}

// seriesCommands maps the CLI command name to its handler and help
var seriesCommands = make(map[string]CommandInfo)

// init populates seriesCommands. The helpXxxContent variables are defined
// in the series_generated_help.go file generated by 'go generate'.
func init() {
	// Public "read" operations for series:
	seriesCommands["retrieveSeries"] = CommandInfo{Handler: handleRetrieveSeries, Help: helpRetrieveSeriesContent}
	seriesCommands["searchSeriesPost"] = CommandInfo{Handler: handleSearchSeriesPost, Help: helpSearchSeriesPostContent}
	seriesCommands["retrieveSeriesCategoryVotes"] = CommandInfo{Handler: handleRetrieveSeriesCategoryVotes, Help: helpRetrieveSeriesCategoryVotesContent}
	seriesCommands["retrieveSeriesComment"] = CommandInfo{Handler: handleRetrieveSeriesComment, Help: helpRetrieveSeriesCommentContent}
	seriesCommands["retrieveMySeriesComment"] = CommandInfo{Handler: handleRetrieveMySeriesComment, Help: helpRetrieveMySeriesCommentContent}
	seriesCommands["retrieveSeriesCommentLocation"] = CommandInfo{Handler: handleRetrieveSeriesCommentLocation, Help: helpRetrieveSeriesCommentLocationContent}
	seriesCommands["searchSeriesCommentsPost"] = CommandInfo{Handler: handleSearchSeriesCommentsPost, Help: helpSearchSeriesCommentsPostContent}
	seriesCommands["retrieveSeriesGroups"] = CommandInfo{Handler: handleRetrieveSeriesGroups, Help: helpRetrieveSeriesGroupsContent}
	seriesCommands["searchSeriesHistoryPost"] = CommandInfo{Handler: handleSearchSeriesHistoryPost, Help: helpSearchSeriesHistoryPostContent}
	seriesCommands["retrieveSeriesLocks"] = CommandInfo{Handler: handleRetrieveSeriesLocks, Help: helpRetrieveSeriesLocksContent}
	seriesCommands["retrieveSeriesRankLocation"] = CommandInfo{Handler: handleRetrieveSeriesRankLocation, Help: helpRetrieveSeriesRankLocationContent}
	seriesCommands["retrieveUserSeriesRating"] = CommandInfo{Handler: handleRetrieveUserSeriesRating, Help: helpRetrieveUserSeriesRatingContent}
	seriesCommands["retrieveSeriesRatingRainbow"] = CommandInfo{Handler: handleRetrieveSeriesRatingRainbow, Help: helpRetrieveSeriesRatingRainbowContent}
	seriesCommands["seriesReleaseRssFeed"] = CommandInfo{Handler: handleSeriesReleaseRssFeed, Help: helpSeriesReleaseRssFeedContent}
}

// HandleCommand dispatches to the correct series command handler
func HandleCommand(command string, args []string) {
	cmdInfo, ok := seriesCommands[command]
	if !ok {
		isJsonHelp, _, _ := utils.CheckHelpFlags(args)
		fmt.Fprintf(os.Stderr, "Error: Unknown series command: %s\n\n", command)
		PrintSeriesSubprogramHelp(isJsonHelp)
		os.Exit(1)
	}
	cmdInfo.Handler(args)
}

// PrintSeriesSubprogramHelp prints help for the entire 'series' subprogram
func PrintSeriesSubprogramHelp(jsonFormat bool) {
	if jsonFormat {
		type CommandHelpSummary struct {
			Command     string `json:"command"`
			Usage       string `json:"usage"`
			Description string `json:"description"`
		}
		var summaries []CommandHelpSummary
		var commandNames []string
		for name := range seriesCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := seriesCommands[name]
			summaries = append(summaries, CommandHelpSummary{
				Command:     name,
				Usage:       cmdInfo.Help.Usage,
				Description: cmdInfo.Help.Description,
			})
		}
		outputData := map[string]interface{}{
			"subprogram":  "series",
			"description": "Commands for retrieving and searching series information.",
			"commands":    summaries,
		}
		jsonData, _ := json.MarshalIndent(outputData, "", "  ")
		fmt.Println(string(jsonData))
	} else {
		fmt.Println("`series` subprogram: Commands for retrieving and searching series information.")
		fmt.Println("Available commands:")
		var commandNames []string
		for name := range seriesCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := seriesCommands[name]
			fmt.Printf("  %-30s %s\n", name, cmdInfo.Help.Description) // Adjusted for potentially longer names
		}
		fmt.Println("\nUse 'mangaupdatescli series <command> -hh' for more detailed help on a specific command.")
	}
}

// --- Handler Functions (Implementations for each command) ---

// handleRetrieveSeries (GET /series/{id})
func handleRetrieveSeries(args []string) {
	fs := flag.NewFlagSet("retrieveSeries", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")
	unrenderedFields := fs.Bool("unrenderedFields", false, "Output fields in unrendered form.")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveSeries'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveSeriesContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveSeriesContent)
		return
	}

	if *seriesID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrieveSeries.")
		utils.PrintFormattedHelp(helpRetrieveSeriesContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d", *seriesID)
	queryParams := make(map[string]string)
	if *unrenderedFields {
		queryParams["unrenderedFields"] = "true"
	}

	fullURL, err := apiclient.BuildURL(path, queryParams)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /series/{id}", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /series/{id}", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /series/{id} failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// Define SeriesSearchRequestV1 (from OpenAPI spec, ensure it's complete for all desired flags)
type SeriesSearchRequestV1 struct {
	Search                string   `json:"search,omitempty"`
	AddedBy               int64    `json:"added_by,omitempty"`
	Stype                 string   `json:"stype,omitempty"`
	Licensed              string   `json:"licensed,omitempty"`
	Type                  []string `json:"type,omitempty"`
	Year                  string   `json:"year,omitempty"`
	FilterTypes           []string `json:"filter_types,omitempty"`
	Category              []string `json:"category,omitempty"`
	Pubname               string   `json:"pubname,omitempty"`
	Filters               []string `json:"filters,omitempty"`
	List                  string   `json:"list,omitempty"`
	Page                  int      `json:"page,omitempty"`
	Perpage               int      `json:"perpage,omitempty"`
	Letter                string   `json:"letter,omitempty"`
	Genre                 []string `json:"genre,omitempty"`
	ExcludeGenre          []string `json:"exclude_genre,omitempty"`
	Orderby               string   `json:"orderby,omitempty"`
	Pending               *bool    `json:"pending,omitempty"`
	IncludeRankMetadata   *bool    `json:"include_rank_metadata,omitempty"`
	ExcludeFilteredGenres *bool    `json:"exclude_filtered_genres,omitempty"`
}

// handleSearchSeriesPost (POST /series/search) - (Already scaffolded, ensure flags are comprehensive)
func handleSearchSeriesPost(args []string) {
	fs := flag.NewFlagSet("searchSeriesPost", flag.ContinueOnError)
	var reqBody SeriesSearchRequestV1

	fs.StringVar(&reqBody.Search, "search", "", "Search term.")
	addedBy := fs.Int64("added_by", 0, "Filter by user ID who added the series.")
	fs.StringVar(&reqBody.Stype, "stype", "", "Search type (title, description).")
	fs.StringVar(&reqBody.Licensed, "licensed", "", "Filter by licensed status (yes, no).")
	typeStr := fs.String("type", "", "Comma-separated list of series types (Manga,Manhwa).")
	fs.StringVar(&reqBody.Year, "year", "", "Filter by year.")
	filterTypesStr := fs.String("filter_types", "", "Comma-separated list of types to filter out.")
	categoryStr := fs.String("category", "", "Comma-separated list of categories.")
	fs.StringVar(&reqBody.Pubname, "pubname", "", "Filter by publication name.")
	filtersStr := fs.String("filters", "", "Comma-separated list of filters (scanlated,completed).")
	fs.StringVar(&reqBody.List, "list", "", "Filter by user list type.")
	fs.IntVar(&reqBody.Page, "page", 0, "Page number.")
	fs.IntVar(&reqBody.Perpage, "perpage", 0, "Results per page.")
	fs.StringVar(&reqBody.Letter, "letter", "", "Filter by starting letter.")
	genreStr := fs.String("genre", "", "Comma-separated list of genres.")
	excludeGenreStr := fs.String("exclude_genre", "", "Comma-separated list of genres to exclude.")
	fs.StringVar(&reqBody.Orderby, "orderby", "", "Order by (score, title, rank, etc.).")
	pendingStr := fs.String("pending", "", "Include pending series (true/false).")
	includeRankStr := fs.String("include_rank_metadata", "", "Include rank metadata (true/false).")
	excludeFilteredGenresStr := fs.String("exclude_filtered_genres", "", "Exclude filtered genres (true/false).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'searchSeriesPost'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpSearchSeriesPostContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSearchSeriesPostContent)
		return
	}
	if *addedBy != 0 {
		reqBody.AddedBy = *addedBy
	}
	if *typeStr != "" {
		reqBody.Type = strings.Split(*typeStr, ",")
	}
	if *filterTypesStr != "" {
		reqBody.FilterTypes = strings.Split(*filterTypesStr, ",")
	}
	if *categoryStr != "" {
		reqBody.Category = strings.Split(*categoryStr, ",")
	}
	if *filtersStr != "" {
		reqBody.Filters = strings.Split(*filtersStr, ",")
	}
	if *genreStr != "" {
		reqBody.Genre = strings.Split(*genreStr, ",")
	}
	if *excludeGenreStr != "" {
		reqBody.ExcludeGenre = strings.Split(*excludeGenreStr, ",")
	}
	if *pendingStr != "" {
		val := strings.ToLower(*pendingStr) == "true"
		reqBody.Pending = &val
	}
	if *includeRankStr != "" {
		val := strings.ToLower(*includeRankStr) == "true"
		reqBody.IncludeRankMetadata = &val
	}
	if *excludeFilteredGenresStr != "" {
		val := strings.ToLower(*excludeFilteredGenresStr) == "true"
		reqBody.ExcludeFilteredGenres = &val
	}

	fullURL, err := apiclient.BuildURL("/series/search", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /series/search", err)
	}
	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /series/search", err)
	}
	if statusCode == http.StatusOK {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /series/search failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveSeriesCategoryVotes (GET /series/{id}/categories/votes)
func handleRetrieveSeriesCategoryVotes(args []string) {
	fs := flag.NewFlagSet("retrieveSeriesCategoryVotes", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags: "+err.Error(), nil)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveSeriesCategoryVotesContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveSeriesCategoryVotesContent)
		return
	}
	if *seriesID == 0 {
		utils.PrintErrorAndExit("--id is required.", nil)
		utils.PrintFormattedHelp(helpRetrieveSeriesCategoryVotesContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/categories/votes", *seriesID)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	// This endpoint likely requires auth to show user-specific votes.
	// Without auth, it might return 200 with empty data, or 401/403.
	if statusCode == http.StatusOK || statusCode == http.StatusUnauthorized || statusCode == http.StatusForbidden {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveSeriesComment (GET /series/{id}/comments/{comment_id})
func handleRetrieveSeriesComment(args []string) {
	fs := flag.NewFlagSet("retrieveSeriesComment", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")
	commentID := fs.Int64("comment_id", 0, "Comment ID (required).")
	unrenderedFields := fs.Bool("unrenderedFields", false, "Output unrendered fields.")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveSeriesCommentContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveSeriesCommentContent)
		return
	}
	if *seriesID == 0 || *commentID == 0 {
		utils.PrintErrorAndExit("--id and --comment_id are required.", nil)
		utils.PrintFormattedHelp(helpRetrieveSeriesCommentContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/comments/%d", *seriesID, *commentID)
	queryParams := make(map[string]string)
	if *unrenderedFields {
		queryParams["unrenderedFields"] = "true"
	}
	fullURL, _ := apiclient.BuildURL(path, queryParams)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveMySeriesComment (GET /series/{id}/comments/my_comment)
func handleRetrieveMySeriesComment(args []string) {
	fs := flag.NewFlagSet("retrieveMySeriesComment", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")
	unrenderedFields := fs.Bool("unrenderedFields", false, "Output unrendered fields.")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveMySeriesCommentContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveMySeriesCommentContent)
		return
	}
	if *seriesID == 0 {
		utils.PrintErrorAndExit("--id is required.", nil)
		utils.PrintFormattedHelp(helpRetrieveMySeriesCommentContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/comments/my_comment", *seriesID)
	queryParams := make(map[string]string)
	if *unrenderedFields {
		queryParams["unrenderedFields"] = "true"
	}
	fullURL, _ := apiclient.BuildURL(path, queryParams)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	// Expects auth. Without it, likely 401/403 or 404 if "my_comment" isn't found due to no auth.
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound || statusCode == http.StatusUnauthorized || statusCode == http.StatusForbidden {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveSeriesCommentLocation (GET /series/{id}/comments/{comment_id}/location)
func handleRetrieveSeriesCommentLocation(args []string) {
	fs := flag.NewFlagSet("retrieveSeriesCommentLocation", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")
	commentID := fs.Int64("comment_id", 0, "Comment ID (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveSeriesCommentLocationContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveSeriesCommentLocationContent)
		return
	}
	if *seriesID == 0 || *commentID == 0 {
		utils.PrintErrorAndExit("--id and --comment_id are required.", nil)
		utils.PrintFormattedHelp(helpRetrieveSeriesCommentLocationContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/comments/%d/location", *seriesID, *commentID)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	// Returns ApiResponseV1, so 200 is expected. 404 if not found.
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// Define SeriesCommentSearchRequestV1
type SeriesCommentSearchRequestV1 struct {
	Method  string `json:"method,omitempty"` // useful, time_added
	AddedBy int64  `json:"added_by,omitempty"`
	Page    int    `json:"page,omitempty"`
	Perpage int    `json:"perpage,omitempty"`
}

// handleSearchSeriesCommentsPost (POST /series/{id}/comments/search)
func handleSearchSeriesCommentsPost(args []string) {
	fs := flag.NewFlagSet("searchSeriesCommentsPost", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")
	var reqBody SeriesCommentSearchRequestV1
	fs.StringVar(&reqBody.Method, "method", "", "Search method (useful, time_added).")
	addedBy := fs.Int64("added_by", 0, "Filter by author user ID.")
	fs.IntVar(&reqBody.Page, "page", 0, "Page number.")
	fs.IntVar(&reqBody.Perpage, "perpage", 0, "Results per page.")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpSearchSeriesCommentsPostContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSearchSeriesCommentsPostContent)
		return
	}
	if *seriesID == 0 {
		utils.PrintErrorAndExit("--id is required.", nil)
		utils.PrintFormattedHelp(helpSearchSeriesCommentsPostContent)
		os.Exit(1)
	}
	if *addedBy != 0 {
		reqBody.AddedBy = *addedBy
	}

	path := fmt.Sprintf("/series/%d/comments/search", *seriesID)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	if statusCode == http.StatusOK {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveSeriesGroups (GET /series/{id}/groups)
func handleRetrieveSeriesGroups(args []string) {
	fs := flag.NewFlagSet("retrieveSeriesGroups", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveSeriesGroupsContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveSeriesGroupsContent)
		return
	}
	if *seriesID == 0 {
		utils.PrintErrorAndExit("--id is required.", nil)
		utils.PrintFormattedHelp(helpRetrieveSeriesGroupsContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/groups", *seriesID)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// Define PerPageSearchRequestV1 (common schema used by history)
type PerPageSearchRequestV1 struct {
	Page    int `json:"page,omitempty"`
	Perpage int `json:"perpage,omitempty"`
}

// handleSearchSeriesHistoryPost (POST /series/{id}/history)
func handleSearchSeriesHistoryPost(args []string) {
	fs := flag.NewFlagSet("searchSeriesHistoryPost", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")
	var reqBody PerPageSearchRequestV1
	fs.IntVar(&reqBody.Page, "page", 0, "Page number.")
	fs.IntVar(&reqBody.Perpage, "perpage", 0, "Results per page.")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpSearchSeriesHistoryPostContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSearchSeriesHistoryPostContent)
		return
	}
	if *seriesID == 0 {
		utils.PrintErrorAndExit("--id is required.", nil)
		utils.PrintFormattedHelp(helpSearchSeriesHistoryPostContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/history", *seriesID)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	if statusCode == http.StatusOK { // 400 for validation error
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveSeriesLocks (GET /series/{id}/locks)
func handleRetrieveSeriesLocks(args []string) {
	fs := flag.NewFlagSet("retrieveSeriesLocks", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveSeriesLocksContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveSeriesLocksContent)
		return
	}
	if *seriesID == 0 {
		utils.PrintErrorAndExit("--id is required.", nil)
		utils.PrintFormattedHelp(helpRetrieveSeriesLocksContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/locks", *seriesID)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	// This endpoint might require auth. Spec shows 200, 404.
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveSeriesRankLocation (GET /series/{id}/rank/{type})
func handleRetrieveSeriesRankLocation(args []string) {
	fs := flag.NewFlagSet("retrieveSeriesRankLocation", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")
	rankType := fs.String("type", "", "Stat type for rank (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveSeriesRankLocationContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveSeriesRankLocationContent)
		return
	}
	if *seriesID == 0 || *rankType == "" {
		utils.PrintErrorAndExit("--id and --type are required.", nil)
		utils.PrintFormattedHelp(helpRetrieveSeriesRankLocationContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/rank/%s", *seriesID, *rankType)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	// Returns ApiResponseV1, so 200 is expected. Might be 404 if series or type is invalid.
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveUserSeriesRating (GET /series/{id}/rating)
func handleRetrieveUserSeriesRating(args []string) {
	fs := flag.NewFlagSet("retrieveUserSeriesRating", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveUserSeriesRatingContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveUserSeriesRatingContent)
		return
	}
	if *seriesID == 0 {
		utils.PrintErrorAndExit("--id is required.", nil)
		utils.PrintFormattedHelp(helpRetrieveUserSeriesRatingContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/rating", *seriesID)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	// Expects auth for user-specific rating. 200 if found, 404 if series not found or no rating for user.
	// 401/403 without auth.
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound || statusCode == http.StatusUnauthorized || statusCode == http.StatusForbidden {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveSeriesRatingRainbow (GET /series/{id}/ratingrainbow)
func handleRetrieveSeriesRatingRainbow(args []string) {
	fs := flag.NewFlagSet("retrieveSeriesRatingRainbow", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveSeriesRatingRainbowContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveSeriesRatingRainbowContent)
		return
	}
	if *seriesID == 0 {
		utils.PrintErrorAndExit("--id is required.", nil)
		utils.PrintFormattedHelp(helpRetrieveSeriesRatingRainbowContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/ratingrainbow", *seriesID)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleSeriesReleaseRssFeed (GET /series/{id}/rss)
func handleSeriesReleaseRssFeed(args []string) {
	fs := flag.NewFlagSet("seriesReleaseRssFeed", flag.ContinueOnError)
	seriesID := fs.Int64("id", 0, "Series ID (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Flag parsing error", err)
	}
	if isJsonHelp {
		utils.PrintJSONHelp(helpSeriesReleaseRssFeedContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSeriesReleaseRssFeedContent)
		return
	}
	if *seriesID == 0 {
		utils.PrintErrorAndExit("--id is required.", nil)
		utils.PrintFormattedHelp(helpSeriesReleaseRssFeedContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/series/%d/rss", *seriesID)
	fullURL, _ := apiclient.BuildURL(path, nil)
	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)

	if err != nil {
		utils.PrintErrorAndExit("API request failed", err)
	}
	if statusCode == http.StatusOK {
		fmt.Println(string(respBody)) // XML output
	} else {
		fmt.Fprintf(os.Stderr, "API request failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}
