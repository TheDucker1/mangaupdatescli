// cmd/releases/releases.go
package releases

import (
	"encoding/json"
	"flag"
	"fmt"
	"mangaupdatescli/internal/apiclient"
	"mangaupdatescli/internal/utils"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
)

// CommandHandler defines the function signature for command handlers
type CommandHandler func(args []string)

// CommandInfo stores the handler and its associated (generated) help content
type CommandInfo struct {
	Handler CommandHandler
	Help    utils.HelpContent
}

// releasesCommands maps the CLI command name to its handler and help
var releasesCommands = make(map[string]CommandInfo)

// init populates releasesCommands. The helpXxxContent variables are defined
// in the releases_generated_help.go file generated by 'go generate'.
func init() {
	// Public "read" operations for releases:
	// operationId: retrieveRelease
	// operationId: listReleasesByDay
	// operationId: releaseRssFeed
	// operationId: searchReleasesPost

	releasesCommands["retrieveRelease"] = CommandInfo{
		Handler: handleRetrieveRelease,
		Help:    helpRetrieveReleaseContent, // From generated file
	}
	releasesCommands["listReleasesByDay"] = CommandInfo{
		Handler: handleListReleasesByDay,
		Help:    helpListReleasesByDayContent, // From generated file
	}
	releasesCommands["releaseRssFeed"] = CommandInfo{
		Handler: handleReleaseRssFeed,
		Help:    helpReleaseRssFeedContent, // From generated file
	}
	releasesCommands["searchReleasesPost"] = CommandInfo{
		Handler: handleSearchReleasesPost,
		Help:    helpSearchReleasesPostContent, // From generated file
	}
}

// HandleCommand dispatches to the correct releases command handler
func HandleCommand(command string, args []string) {
	cmdInfo, ok := releasesCommands[command]
	if !ok {
		isJsonHelp, _, _ := utils.CheckHelpFlags(args)
		fmt.Fprintf(os.Stderr, "Error: Unknown releases command: %s\n\n", command)
		PrintReleasesSubprogramHelp(isJsonHelp)
		os.Exit(1)
	}
	cmdInfo.Handler(args)
}

// PrintReleasesSubprogramHelp prints help for the entire 'releases' subprogram
func PrintReleasesSubprogramHelp(jsonFormat bool) {
	if jsonFormat {
		type CommandHelpSummary struct {
			Command     string `json:"command"`
			Usage       string `json:"usage"`
			Description string `json:"description"`
		}
		var summaries []CommandHelpSummary
		var commandNames []string
		for name := range releasesCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := releasesCommands[name]
			summaries = append(summaries, CommandHelpSummary{
				Command:     name,
				Usage:       cmdInfo.Help.Usage,
				Description: cmdInfo.Help.Description,
			})
		}
		outputData := map[string]interface{}{
			"subprogram":  "releases",
			"description": "Commands for retrieving and searching release information.",
			"commands":    summaries,
		}
		jsonData, _ := json.MarshalIndent(outputData, "", "  ")
		fmt.Println(string(jsonData))
	} else {
		fmt.Println("`releases` subprogram: Commands for retrieving and searching release information.")
		fmt.Println("Available commands:")
		var commandNames []string
		for name := range releasesCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := releasesCommands[name]
			fmt.Printf("  %-30s %s\n", name, cmdInfo.Help.Description)
		}
		fmt.Println("\nUse 'mangaupdatescli releases <command> -hh' for more detailed help on a specific command.")
	}
}

// --- Handler Functions ---

// handleRetrieveRelease (GET /releases/{id})
func handleRetrieveRelease(args []string) {
	fs := flag.NewFlagSet("retrieveRelease", flag.ContinueOnError)
	releaseID := fs.Int64("id", 0, "Release ID (required).")
	unrenderedFields := fs.Bool("unrenderedFields", false, "Output fields in unrendered form.")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveRelease'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveReleaseContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveReleaseContent)
		return
	}

	if *releaseID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrieveRelease.")
		utils.PrintFormattedHelp(helpRetrieveReleaseContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/releases/%d", *releaseID)
	queryParams := make(map[string]string)
	if *unrenderedFields {
		queryParams["unrenderedFields"] = "true"
	}

	fullURL, err := apiclient.BuildURL(path, queryParams)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /releases/{id}", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /releases/{id}", err)
	}

	// Note: The spec mentions 401 for this endpoint. If it strictly requires auth even for GET,
	// this unauthenticated call will fail with 401. We handle common cases.
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /releases/{id} failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleListReleasesByDay (GET /releases/days)
func handleListReleasesByDay(args []string) {
	fs := flag.NewFlagSet("listReleasesByDay", flag.ContinueOnError)
	page := fs.Int64("page", 0, "Start page (optional).") // Default will be API's default
	includeMetadataStr := fs.String("include_metadata", "", "Include series metadata (true/false, default: false).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'listReleasesByDay'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpListReleasesByDayContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpListReleasesByDayContent)
		return
	}

	queryParams := make(map[string]string)
	if *page > 0 { // Only add if specified, to let API use its default
		queryParams["page"] = strconv.FormatInt(*page, 10)
	}
	if *includeMetadataStr != "" { // Default is false, so only add if user specifies 'true'
		if strings.ToLower(*includeMetadataStr) == "true" {
			queryParams["include_metadata"] = "true"
		} else if strings.ToLower(*includeMetadataStr) == "false" {
			queryParams["include_metadata"] = "false" // Explicitly false if user wants
		}
	}

	fullURL, err := apiclient.BuildURL("/releases/days", queryParams)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /releases/days", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /releases/days", err)
	}

	if statusCode == http.StatusOK {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /releases/days failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleReleaseRssFeed (GET /releases/rss)
func handleReleaseRssFeed(args []string) {
	fs := flag.NewFlagSet("releaseRssFeed", flag.ContinueOnError)
	// No arguments for this endpoint

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'releaseRssFeed'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpReleaseRssFeedContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpReleaseRssFeedContent)
		return
	}

	fullURL, err := apiclient.BuildURL("/releases/rss", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /releases/rss", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /releases/rss", err)
	}

	if statusCode == http.StatusOK {
		// This endpoint returns XML, so print it directly
		fmt.Println(string(respBody))
	} else {
		// If it's an error, it might be JSON from ApiResponseV1
		fmt.Fprintf(os.Stderr, "API request for /releases/rss failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody) // Attempt to print as JSON if error
		os.Exit(1)
	}
}

// Define ReleaseSearchRequestV1 (from OpenAPI spec, simplified)
type ReleaseSearchRequestV1 struct {
	Search          string `json:"search,omitempty"`
	SearchType      string `json:"search_type,omitempty"` // enum: series, regular
	AddedBy         int64  `json:"added_by,omitempty"`
	Page            int    `json:"page,omitempty"`
	Perpage         int    `json:"perpage,omitempty"`
	Letter          string `json:"letter,omitempty"`
	Orderby         string `json:"orderby,omitempty"`    // enum: date, time, title, vol, chap
	StartDate       string `json:"start_date,omitempty"` // format: date
	EndDate         string `json:"end_date,omitempty"`   // format: date
	Asc             string `json:"asc,omitempty"`        // enum: asc, desc
	GroupID         int64  `json:"group_id,omitempty"`
	Pending         *bool  `json:"pending,omitempty"`
	IncludeMetadata *bool  `json:"include_metadata,omitempty"`
}

// handleSearchReleasesPost (POST /releases/search)
func handleSearchReleasesPost(args []string) {
	fs := flag.NewFlagSet("searchReleasesPost", flag.ContinueOnError)
	var reqBody ReleaseSearchRequestV1

	fs.StringVar(&reqBody.Search, "search", "", "Search term.")
	fs.StringVar(&reqBody.SearchType, "search_type", "", "Search type (series, regular).")
	addedBy := fs.Int64("added_by", 0, "Filter by user ID who added the release.")
	fs.IntVar(&reqBody.Page, "page", 0, "Page number.")
	fs.IntVar(&reqBody.Perpage, "perpage", 0, "Results per page.")
	fs.StringVar(&reqBody.Letter, "letter", "", "Filter by starting letter.")
	fs.StringVar(&reqBody.Orderby, "orderby", "date", "Order by (default: date).") // Defaulting here as per common use
	fs.StringVar(&reqBody.StartDate, "start_date", "", "Start date (YYYY-MM-DD).")
	fs.StringVar(&reqBody.EndDate, "end_date", "", "End date (YYYY-MM-DD).")
	fs.StringVar(&reqBody.Asc, "asc", "desc", "Sort direction (asc, desc; default: desc).") // Defaulting
	groupID := fs.Int64("group_id", 0, "Filter by group ID.")
	pendingStr := fs.String("pending", "", "Include pending releases (true/false).")
	includeMetadataStr := fs.String("include_metadata", "", "Include series metadata (true/false).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'searchReleasesPost'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpSearchReleasesPostContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSearchReleasesPostContent)
		return
	}

	if *addedBy != 0 {
		reqBody.AddedBy = *addedBy
	}
	if *groupID != 0 {
		reqBody.GroupID = *groupID
	}
	if *pendingStr != "" {
		val := strings.ToLower(*pendingStr) == "true"
		reqBody.Pending = &val
	}
	if *includeMetadataStr != "" {
		val := strings.ToLower(*includeMetadataStr) == "true"
		reqBody.IncludeMetadata = &val
	}

	fullURL, err := apiclient.BuildURL("/releases/search", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /releases/search", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /releases/search", err)
	}

	if statusCode == http.StatusOK {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /releases/search failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}
