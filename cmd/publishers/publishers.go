// cmd/publishers/publishers.go
package publishers

import (
	"encoding/json"
	"flag"
	"fmt"
	"mangaupdatescli/internal/apiclient"
	"mangaupdatescli/internal/utils"
	"net/http"
	"os"
	"sort"
	"strings"
)

// CommandHandler defines the function signature for command handlers
type CommandHandler func(args []string)

// CommandInfo stores the handler and its associated (generated) help content
type CommandInfo struct {
	Handler CommandHandler
	Help    utils.HelpContent
}

// publishersCommands maps the CLI command name to its handler and help
var publishersCommands = make(map[string]CommandInfo)

// init populates publishersCommands. The helpXxxContent variables are defined
// in the publishers_generated_help.go file generated by 'go generate'.
func init() {
	// Public "read" operations for publishers:
	// operationId: retrievePublisher
	// operationId: searchPublishersPost
	// operationId: retrievePublisherSeries
	// operationId: retrievePublicationSeries

	publishersCommands["retrievePublisher"] = CommandInfo{
		Handler: handleRetrievePublisher,
		Help:    helpRetrievePublisherContent, // From generated file
	}
	publishersCommands["searchPublishersPost"] = CommandInfo{
		Handler: handleSearchPublishersPost,
		Help:    helpSearchPublishersPostContent, // From generated file
	}
	publishersCommands["retrievePublisherSeries"] = CommandInfo{
		Handler: handleRetrievePublisherSeries,
		Help:    helpRetrievePublisherSeriesContent, // From generated file
	}
	publishersCommands["retrievePublicationSeries"] = CommandInfo{
		Handler: handleRetrievePublicationSeries,
		Help:    helpRetrievePublicationSeriesContent, // From generated file
	}
}

// HandleCommand dispatches to the correct publishers command handler
func HandleCommand(command string, args []string) {
	cmdInfo, ok := publishersCommands[command]
	if !ok {
		isJsonHelp, _, _ := utils.CheckHelpFlags(args)
		fmt.Fprintf(os.Stderr, "Error: Unknown publishers command: %s\n\n", command)
		PrintPublishersSubprogramHelp(isJsonHelp)
		os.Exit(1)
	}
	cmdInfo.Handler(args)
}

// PrintPublishersSubprogramHelp prints help for the entire 'publishers' subprogram
func PrintPublishersSubprogramHelp(jsonFormat bool) {
	if jsonFormat {
		type CommandHelpSummary struct {
			Command     string `json:"command"`
			Usage       string `json:"usage"`
			Description string `json:"description"`
		}
		var summaries []CommandHelpSummary
		var commandNames []string
		for name := range publishersCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := publishersCommands[name]
			summaries = append(summaries, CommandHelpSummary{
				Command:     name,
				Usage:       cmdInfo.Help.Usage,
				Description: cmdInfo.Help.Description,
			})
		}
		outputData := map[string]interface{}{
			"subprogram":  "publishers",
			"description": "Commands for retrieving and searching publisher and publication information.",
			"commands":    summaries,
		}
		jsonData, _ := json.MarshalIndent(outputData, "", "  ")
		fmt.Println(string(jsonData))
	} else {
		fmt.Println("`publishers` subprogram: Commands for retrieving and searching publisher and publication information.")
		fmt.Println("Available commands:")
		var commandNames []string
		for name := range publishersCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := publishersCommands[name]
			fmt.Printf("  %-30s %s\n", name, cmdInfo.Help.Description)
		}
		fmt.Println("\nUse 'mangaupdatescli publishers <command> -hh' for more detailed help on a specific command.")
	}
}

// --- Handler Functions ---

// handleRetrievePublisher (GET /publishers/{id})
func handleRetrievePublisher(args []string) {
	fs := flag.NewFlagSet("retrievePublisher", flag.ContinueOnError)
	publisherID := fs.Int64("id", 0, "Publisher ID (required).")
	unrenderedFields := fs.Bool("unrenderedFields", false, "Output fields in unrendered form.")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrievePublisher'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrievePublisherContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrievePublisherContent)
		return
	}

	if *publisherID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrievePublisher.")
		utils.PrintFormattedHelp(helpRetrievePublisherContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/publishers/%d", *publisherID)
	queryParams := make(map[string]string)
	if *unrenderedFields {
		queryParams["unrenderedFields"] = "true"
	}

	fullURL, err := apiclient.BuildURL(path, queryParams)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /publishers/{id}", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /publishers/{id}", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /publishers/{id} failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// Define PublishersSearchRequestV1 for the request body
type PublishersSearchRequestV1 struct {
	Search  string `json:"search,omitempty"`
	AddedBy int64  `json:"added_by,omitempty"`
	Page    int    `json:"page,omitempty"`
	Perpage int    `json:"perpage,omitempty"`
	Letter  string `json:"letter,omitempty"`
	Orderby string `json:"orderby,omitempty"` // enum: score, name, series, publications, type
	Pending *bool  `json:"pending,omitempty"`
}

// handleSearchPublishersPost (POST /publishers/search)
func handleSearchPublishersPost(args []string) {
	fs := flag.NewFlagSet("searchPublishersPost", flag.ContinueOnError)
	var reqBody PublishersSearchRequestV1

	fs.StringVar(&reqBody.Search, "search", "", "Search term for publishers.")
	addedBy := fs.Int64("added_by", 0, "Filter by user ID who added the publisher.")
	fs.IntVar(&reqBody.Page, "page", 0, "Page number.")
	fs.IntVar(&reqBody.Perpage, "perpage", 0, "Results per page.")
	fs.StringVar(&reqBody.Letter, "letter", "", "Filter by starting letter.")
	fs.StringVar(&reqBody.Orderby, "orderby", "", "Order by (score, name, series, etc.).")
	pendingStr := fs.String("pending", "", "Filter by pending status (true/false).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'searchPublishersPost'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpSearchPublishersPostContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSearchPublishersPostContent)
		return
	}

	if *addedBy != 0 {
		reqBody.AddedBy = *addedBy
	}
	if *pendingStr != "" {
		val := strings.ToLower(*pendingStr) == "true"
		reqBody.Pending = &val
	}

	fullURL, err := apiclient.BuildURL("/publishers/search", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /publishers/search", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /publishers/search", err)
	}

	if statusCode == http.StatusOK {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /publishers/search failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrievePublisherSeries (GET /publishers/{id}/series)
func handleRetrievePublisherSeries(args []string) {
	fs := flag.NewFlagSet("retrievePublisherSeries", flag.ContinueOnError)
	publisherID := fs.Int64("id", 0, "Publisher ID (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrievePublisherSeries'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrievePublisherSeriesContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrievePublisherSeriesContent)
		return
	}

	if *publisherID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrievePublisherSeries.")
		utils.PrintFormattedHelp(helpRetrievePublisherSeriesContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/publishers/%d/series", *publisherID)
	fullURL, err := apiclient.BuildURL(path, nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /publishers/{id}/series", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /publishers/{id}/series", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /publishers/{id}/series failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrievePublicationSeries (GET /publishers/publication)
func handleRetrievePublicationSeries(args []string) {
	fs := flag.NewFlagSet("retrievePublicationSeries", flag.ContinueOnError)
	pubname := fs.String("pubname", "", "Publication name (required).") // Query parameter

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrievePublicationSeries'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrievePublicationSeriesContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrievePublicationSeriesContent)
		return
	}

	if *pubname == "" {
		fmt.Fprintln(os.Stderr, "Error: --pubname is required for retrievePublicationSeries.")
		utils.PrintFormattedHelp(helpRetrievePublicationSeriesContent)
		os.Exit(1)
	}

	queryParams := make(map[string]string)
	queryParams["pubname"] = *pubname

	fullURL, err := apiclient.BuildURL("/publishers/publication", queryParams)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /publishers/publication", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /publishers/publication", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound { // 404 if publication not found
		utils.PrintJSON(respBody)
	} else {
		// 400 for validation error (e.g. missing pubname, though we check for it)
		fmt.Fprintf(os.Stderr, "API request for /publishers/publication failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}
