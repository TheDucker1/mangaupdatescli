// cmd/categories/categories.go
package categories

import (
	"encoding/json"
	"flag"
	"fmt"
	"mangaupdatescli/internal/apiclient"
	"mangaupdatescli/internal/utils"
	"net/http"
	"os"
	"sort"
	// "strings" // Not immediately needed, but common
)

// CommandHandler defines the function signature for command handlers
type CommandHandler func(args []string)

// CommandInfo stores the handler and its associated (generated) help content
type CommandInfo struct {
	Handler CommandHandler
	Help    utils.HelpContent
}

// categoriesCommands maps the CLI command name to its handler and help
var categoriesCommands = make(map[string]CommandInfo)

// init populates categoriesCommands. The helpXxxContent variables are defined
// in the categories_generated_help.go file generated by 'go generate'.
func init() {
	// Public "read" operations for categories:
	// operationId: findCategoryByPrefix
	// operationId: findCategoryByExact
	// operationId: searchCategoriesPost

	// Ensure helpFindCategoryByPrefixContent is defined in categories_generated_help.go
	categoriesCommands["findCategoryByPrefix"] = CommandInfo{
		Handler: handleFindCategoryByPrefix,
		Help:    helpFindCategoryByPrefixContent, // This var comes from the generated file
	}

	// Ensure helpFindCategoryByExactContent is defined in categories_generated_help.go
	categoriesCommands["findCategoryByExact"] = CommandInfo{
		Handler: handleFindCategoryByExact,
		Help:    helpFindCategoryByExactContent,
	}

	// Ensure helpSearchCategoriesPostContent is defined in categories_generated_help.go
	categoriesCommands["searchCategoriesPost"] = CommandInfo{
		Handler: handleSearchCategoriesPost,
		Help:    helpSearchCategoriesPostContent,
	}
}

// HandleCommand dispatches to the correct categories command handler
func HandleCommand(command string, args []string) {
	cmdInfo, ok := categoriesCommands[command]
	if !ok {
		isJsonHelp, _, _ := utils.CheckHelpFlags(args)
		fmt.Fprintf(os.Stderr, "Error: Unknown categories command: %s\n\n", command)
		PrintCategoriesSubprogramHelp(isJsonHelp)
		os.Exit(1)
	}
	cmdInfo.Handler(args)
}

// PrintCategoriesSubprogramHelp prints help for the entire 'categories' subprogram
func PrintCategoriesSubprogramHelp(jsonFormat bool) {
	if jsonFormat {
		type CommandHelpSummary struct {
			Command     string `json:"command"`
			Usage       string `json:"usage"`
			Description string `json:"description"`
		}
		var summaries []CommandHelpSummary
		var commandNames []string
		for name := range categoriesCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := categoriesCommands[name]
			summaries = append(summaries, CommandHelpSummary{
				Command:     name,
				Usage:       cmdInfo.Help.Usage,
				Description: cmdInfo.Help.Description,
			})
		}
		outputData := map[string]interface{}{
			"subprogram":  "categories",
			"description": "Commands for finding and searching series categories.",
			"commands":    summaries,
		}
		jsonData, _ := json.MarshalIndent(outputData, "", "  ")
		fmt.Println(string(jsonData))
	} else {
		fmt.Println("`categories` subprogram: Commands for finding and searching series categories.")
		fmt.Println("Available commands:")
		var commandNames []string
		for name := range categoriesCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := categoriesCommands[name]
			fmt.Printf("  %-30s %s\n", name, cmdInfo.Help.Description)
		}
		fmt.Println("\nUse 'mangaupdatescli categories <command> -hh' for more detailed help on a specific command.")
	}
}

// --- Handler Functions ---

// Define CategoriesModelUpdateV1 for request bodies (from OpenAPI spec)
// This schema is used by findCategoryByPrefix and findCategoryByExact
type CategoriesModelUpdateV1 struct {
	Category string `json:"category"` // Required
}

// handleFindCategoryByPrefix (POST /categories/findByPrefix)
func handleFindCategoryByPrefix(args []string) {
	fs := flag.NewFlagSet("findCategoryByPrefix", flag.ContinueOnError)
	var reqBody CategoriesModelUpdateV1
	fs.StringVar(&reqBody.Category, "category", "", "The category prefix to search for (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'findCategoryByPrefix'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpFindCategoryByPrefixContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpFindCategoryByPrefixContent)
		return
	}

	if reqBody.Category == "" {
		fmt.Fprintln(os.Stderr, "Error: --category is required for findCategoryByPrefix.")
		utils.PrintFormattedHelp(helpFindCategoryByPrefixContent)
		os.Exit(1)
	}

	fullURL, err := apiclient.BuildURL("/categories/findByPrefix", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /categories/findByPrefix", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /categories/findByPrefix", err)
	}

	if statusCode == http.StatusOK { // Spec does not list 404 for this, assumes empty array if no match
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /categories/findByPrefix failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody) // Print error response from API (e.g., 400)
		os.Exit(1)
	}
}

// handleFindCategoryByExact (POST /categories/findByExact)
func handleFindCategoryByExact(args []string) {
	fs := flag.NewFlagSet("findCategoryByExact", flag.ContinueOnError)
	var reqBody CategoriesModelUpdateV1
	fs.StringVar(&reqBody.Category, "category", "", "The exact category name to search for (required).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'findCategoryByExact'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpFindCategoryByExactContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpFindCategoryByExactContent)
		return
	}

	if reqBody.Category == "" {
		fmt.Fprintln(os.Stderr, "Error: --category is required for findCategoryByExact.")
		utils.PrintFormattedHelp(helpFindCategoryByExactContent)
		os.Exit(1)
	}

	fullURL, err := apiclient.BuildURL("/categories/findByExact", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /categories/findByExact", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /categories/findByExact", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound { // 404 is an expected response
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /categories/findByExact failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// Define CategoriesSearchRequestV1 for the request body (from OpenAPI spec, simplified)
type CategoriesSearchRequestV1 struct {
	Search  string `json:"search,omitempty"`
	Page    int    `json:"page,omitempty"`
	Perpage int    `json:"perpage,omitempty"`
	Letter  string `json:"letter,omitempty"`
	Orderby string `json:"orderby,omitempty"` // enum: category, agree, disagree, usage
}

// handleSearchCategoriesPost (POST /categories/search)
func handleSearchCategoriesPost(args []string) {
	fs := flag.NewFlagSet("searchCategoriesPost", flag.ContinueOnError)
	var reqBody CategoriesSearchRequestV1

	fs.StringVar(&reqBody.Search, "search", "", "Search term for categories.")
	fs.IntVar(&reqBody.Page, "page", 0, "Page number.")
	fs.IntVar(&reqBody.Perpage, "perpage", 0, "Results per page.")
	fs.StringVar(&reqBody.Letter, "letter", "", "Filter by starting letter.")
	fs.StringVar(&reqBody.Orderby, "orderby", "", "Order by (category, agree, disagree, usage).")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'searchCategoriesPost'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpSearchCategoriesPostContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSearchCategoriesPostContent)
		return
	}

	// No specific required fields for the search request body itself,
	// an empty body is valid for a broad search.

	fullURL, err := apiclient.BuildURL("/categories/search", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /categories/search", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /categories/search", err)
	}

	if statusCode == http.StatusOK { // Expect 200 for success
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /categories/search failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}
