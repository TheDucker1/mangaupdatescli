// cmd/authors/authors.go
package authors

import (
	"encoding/json"
	"flag"
	"fmt"
	"mangaupdatescli/internal/apiclient"
	"mangaupdatescli/internal/utils"
	"net/http"
	"os"
	"sort"
	"strings"
)

// CommandHandler defines the function signature for command handlers
type CommandHandler func(args []string)

// CommandInfo stores the handler and its associated (generated) help content
type CommandInfo struct {
	Handler CommandHandler
	Help    utils.HelpContent
}

// authorsCommands maps the CLI command name to its handler and help
var authorsCommands = make(map[string]CommandInfo)

// init populates authorsCommands. The helpXxxContent variables are defined
// in the authors_generated_help.go file generated by 'go generate'.
func init() {
	// Public "read" operations for authors:
	// operationId: retrieveAuthor
	// operationId: retrieveAuthorLocks
	// operationId: searchAuthorsPost
	// operationId: retrieveAuthorSeries

	// Ensure helpRetrieveAuthorContent is defined in authors_generated_help.go
	authorsCommands["retrieveAuthor"] = CommandInfo{
		Handler: handleRetrieveAuthor,
		Help:    helpRetrieveAuthorContent, // This var comes from the generated file
	}

	// Ensure helpRetrieveAuthorLocksContent is defined in authors_generated_help.go
	authorsCommands["retrieveAuthorLocks"] = CommandInfo{
		Handler: handleRetrieveAuthorLocks,
		Help:    helpRetrieveAuthorLocksContent,
	}

	// Ensure helpSearchAuthorsPostContent is defined in authors_generated_help.go
	authorsCommands["searchAuthorsPost"] = CommandInfo{
		Handler: handleSearchAuthorsPost,
		Help:    helpSearchAuthorsPostContent,
	}

	// Ensure helpRetrieveAuthorSeriesContent is defined in authors_generated_help.go
	authorsCommands["retrieveAuthorSeries"] = CommandInfo{
		Handler: handleRetrieveAuthorSeries,
		Help:    helpRetrieveAuthorSeriesContent,
	}
}

// HandleCommand dispatches to the correct authors command handler
func HandleCommand(command string, args []string) {
	cmdInfo, ok := authorsCommands[command]
	if !ok {
		isJsonHelp, _, _ := utils.CheckHelpFlags(args)
		fmt.Fprintf(os.Stderr, "Error: Unknown authors command: %s\n\n", command)
		PrintAuthorsSubprogramHelp(isJsonHelp)
		os.Exit(1)
	}
	cmdInfo.Handler(args)
}

// PrintAuthorsSubprogramHelp prints help for the entire 'authors' subprogram
func PrintAuthorsSubprogramHelp(jsonFormat bool) {
	if jsonFormat {
		type CommandHelpSummary struct {
			Command     string `json:"command"`
			Usage       string `json:"usage"`
			Description string `json:"description"`
		}
		var summaries []CommandHelpSummary
		var commandNames []string
		for name := range authorsCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := authorsCommands[name]
			summaries = append(summaries, CommandHelpSummary{
				Command:     name,
				Usage:       cmdInfo.Help.Usage,
				Description: cmdInfo.Help.Description,
			})
		}
		outputData := map[string]interface{}{
			"subprogram":  "authors",
			"description": "Commands for retrieving and searching author information.",
			"commands":    summaries,
		}
		jsonData, _ := json.MarshalIndent(outputData, "", "  ")
		fmt.Println(string(jsonData))
	} else {
		fmt.Println("`authors` subprogram: Commands for retrieving and searching author information.")
		fmt.Println("Available commands:")
		var commandNames []string
		for name := range authorsCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := authorsCommands[name]
			fmt.Printf("  %-30s %s\n", name, cmdInfo.Help.Description)
		}
		fmt.Println("\nUse 'mangaupdatescli authors <command> -hh' for more detailed help on a specific command.")
	}
}

// --- Handler Functions ---

// handleRetrieveAuthor (GET /authors/{id})
func handleRetrieveAuthor(args []string) {
	fs := flag.NewFlagSet("retrieveAuthor", flag.ContinueOnError)
	authorID := fs.Int64("id", 0, "Author ID (required).")                                      // From help: Name "id"
	unrenderedFields := fs.Bool("unrenderedFields", false, "Output fields in unrendered form.") // From help: Name "unrenderedFields"

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveAuthor'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveAuthorContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveAuthorContent)
		return
	}

	if *authorID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrieveAuthor.")
		utils.PrintFormattedHelp(helpRetrieveAuthorContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/authors/%d", *authorID)
	queryParams := make(map[string]string)
	if *unrenderedFields {
		queryParams["unrenderedFields"] = "true"
	}

	fullURL, err := apiclient.BuildURL(path, queryParams)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /authors/{id}", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /authors/{id}", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound { // 404 is an expected response
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /authors/{id} failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveAuthorLocks (GET /authors/{id}/locks)
func handleRetrieveAuthorLocks(args []string) {
	fs := flag.NewFlagSet("retrieveAuthorLocks", flag.ContinueOnError)
	authorID := fs.Int64("id", 0, "Author ID (required).") // From help: Name "id"

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveAuthorLocks'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveAuthorLocksContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveAuthorLocksContent)
		return
	}

	if *authorID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrieveAuthorLocks.")
		utils.PrintFormattedHelp(helpRetrieveAuthorLocksContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/authors/%d/locks", *authorID)
	fullURL, err := apiclient.BuildURL(path, nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /authors/{id}/locks", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /authors/{id}/locks", err)
	}

	// This endpoint might require auth in practice, but spec implies it might be readable.
	// If it returns 401/403, that's an API-level restriction.
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound { // 404 if author not found
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /authors/{id}/locks failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleSearchAuthorsPost (POST /authors/search)
// Define AuthorsSearchRequestV1 for the request body (from OpenAPI spec, simplified)
type AuthorsSearchRequestV1 struct {
	Search  string   `json:"search,omitempty"`
	AddedBy int64    `json:"added_by,omitempty"` // Assuming int64, adjust if needed
	Page    int      `json:"page,omitempty"`
	Perpage int      `json:"perpage,omitempty"`
	Letter  string   `json:"letter,omitempty"`
	Genre   []string `json:"genre,omitempty"`
	Orderby string   `json:"orderby,omitempty"` // enum: name, series, score
	Pending bool     `json:"pending,omitempty"`
}

func handleSearchAuthorsPost(args []string) {
	fs := flag.NewFlagSet("searchAuthorsPost", flag.ContinueOnError)
	var reqBody AuthorsSearchRequestV1

	fs.StringVar(&reqBody.Search, "search", "", "Search term.")
	addedBy := fs.Int64("added_by", 0, "Filter by user ID who added the author.") // Flag name matches param in spec
	fs.IntVar(&reqBody.Page, "page", 0, "Page number.")
	fs.IntVar(&reqBody.Perpage, "perpage", 0, "Results per page.")
	fs.StringVar(&reqBody.Letter, "letter", "", "Filter by starting letter.")
	genreStr := fs.String("genre", "", "Comma-separated list of genres.")
	fs.StringVar(&reqBody.Orderby, "orderby", "", "Order by (name, series, score).")
	fs.BoolVar(&reqBody.Pending, "pending", false, "Include pending authors.")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'searchAuthorsPost'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpSearchAuthorsPostContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSearchAuthorsPostContent)
		return
	}

	// Populate struct from flags
	if *addedBy != 0 {
		reqBody.AddedBy = *addedBy
	}
	if *genreStr != "" {
		reqBody.Genre = strings.Split(*genreStr, ",")
	}
	// API defaults will handle page/perpage if 0 and omitempty is used.

	fullURL, err := apiclient.BuildURL("/authors/search", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /authors/search", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /authors/search", err)
	}

	if statusCode == http.StatusOK { // 400 is for validation/service error
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /authors/search failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveAuthorSeries (POST /authors/{id}/series)
type AuthorsSeriesListRequestV1 struct {
	Orderby string `json:"orderby,omitempty"` // enum: title, year
}

func handleRetrieveAuthorSeries(args []string) {
	fs := flag.NewFlagSet("retrieveAuthorSeries", flag.ContinueOnError)
	authorID := fs.Int64("id", 0, "Author ID (required).") // Path parameter
	var reqBody AuthorsSeriesListRequestV1
	fs.StringVar(&reqBody.Orderby, "orderby", "", "Order by (title, year).") // Request body field

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveAuthorSeries'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveAuthorSeriesContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveAuthorSeriesContent)
		return
	}

	if *authorID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrieveAuthorSeries.")
		utils.PrintFormattedHelp(helpRetrieveAuthorSeriesContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/authors/%d/series", *authorID)
	fullURL, err := apiclient.BuildURL(path, nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /authors/{id}/series", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /authors/{id}/series", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound { // 404 if author not found
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /authors/{id}/series failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}
