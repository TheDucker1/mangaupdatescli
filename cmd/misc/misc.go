// cmd/misc/misc.go

package misc

import (
	"encoding/json"
	"flag"
	"fmt"
	"mangaupdatescli/internal/apiclient"
	"mangaupdatescli/internal/utils"
	"net/http"
	"os"
	"sort"
)

type MiscCommandHandler func(args []string)

type CommandInfo struct {
	Handler MiscCommandHandler
	Help    utils.HelpContent
}

var miscCommands = make(map[string]CommandInfo)

// init populates miscCommands. The helpXxxContent variables are defined
// in the misc_generated_help.go file generated by 'go generate'.
func init() {
	// The CLI command name should match the operationId or a chosen alias.
	// For 'misc' tag, operation IDs are:
	// - time
	// - listOnlineUsers
	// - siteStats
	// - retrieveSlowTransactionStatus

	// Ensure `helpTimeContent` is defined in misc_generated_help.go
	miscCommands["time"] = CommandInfo{
		Handler: handleTime,
		Help:    helpTimeContent, // This var comes from the generated file
	}

	// Ensure `helpListOnlineUsersContent` is defined in misc_generated_help.go
	miscCommands["online"] = CommandInfo{
		Handler: handleListOnlineUsers,
		Help:    helpListOnlineUsersContent,
	}

	// Ensure `helpSiteStatsContent` is defined in misc_generated_help.go
	miscCommands["stats"] = CommandInfo{
		Handler: handleSiteStats,
		Help:    helpSiteStatsContent,
	}

	// Ensure `helpRetrieveSlowTransactionStatusContent` is defined in misc_generated_help.go
	miscCommands["retrieveSlowTransactionStatus"] = CommandInfo{
		Handler: handleRetrieveSlowTransactionStatus,
		Help:    helpRetrieveSlowTransactionStatusContent,
	}
}

// HandleCommand dispatches to the correct misc command handler
func HandleCommand(command string, args []string) {
	cmdInfo, ok := miscCommands[command]
	if !ok {
		isJsonHelp, _, _ := utils.CheckHelpFlags(args) // Check if they tried `misc unknown -h`
		fmt.Fprintf(os.Stderr, "Error: Unknown misc command: %s\n\n", command)
		PrintMiscSubprogramHelp(isJsonHelp) // Show subprogram help if command is unknown
		os.Exit(1)
	}
	cmdInfo.Handler(args)
}

// PrintMiscSubprogramHelp prints help for the entire 'misc' subprogram
func PrintMiscSubprogramHelp(jsonFormat bool) {
	if jsonFormat {
		type CommandHelpSummary struct {
			Command     string `json:"command"`
			Usage       string `json:"usage"`
			Description string `json:"description"`
		}
		var summaries []CommandHelpSummary
		var commandNames []string
		for name := range miscCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames) // For consistent output

		for _, name := range commandNames {
			cmdInfo := miscCommands[name]
			summaries = append(summaries, CommandHelpSummary{
				Command:     name,
				Usage:       cmdInfo.Help.Usage,
				Description: cmdInfo.Help.Description,
			})
		}
		outputData := map[string]interface{}{
			"subprogram":  "misc",
			"description": "Commands related to miscellaneous site utilities and information.",
			"commands":    summaries,
		}
		jsonData, _ := json.MarshalIndent(outputData, "", "  ")
		fmt.Println(string(jsonData))
	} else {
		fmt.Println("`misc` subprogram: Commands related to miscellaneous site utilities and information.")
		fmt.Println("Available commands:")
		var commandNames []string
		for name := range miscCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := miscCommands[name]
			fmt.Printf("  %-30s %s\n", name, cmdInfo.Help.Description)
		}
		fmt.Println("\nUse 'mangaupdatescli misc <command> -hh' for more detailed help on a specific command.")
	}
}

// --- Handler Functions ---

// handleTime corresponds to operationId: time
func handleTime(args []string) {
	fs := flag.NewFlagSet("time", flag.ContinueOnError)

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'time' command", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpTimeContent) // Uses generated helpTimeContent
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpTimeContent) // Uses generated helpTimeContent
		return
	}

	fullURL, err := apiclient.BuildURL("/misc/time", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /misc/time", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /misc/time", err)
	}

	if statusCode == http.StatusOK {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /misc/time failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleListOnlineUsers corresponds to operationId: listOnlineUsers
func handleListOnlineUsers(args []string) {
	fs := flag.NewFlagSet("online", flag.ContinueOnError) // CLI command is "online"

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'online' command", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpListOnlineUsersContent) // Uses generated help
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpListOnlineUsersContent) // Uses generated help
		return
	}

	fullURL, err := apiclient.BuildURL("/misc/online", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /misc/online", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /misc/online", err)
	}

	if statusCode == http.StatusOK {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /misc/online failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleSiteStats corresponds to operationId: siteStats
func handleSiteStats(args []string) {
	fs := flag.NewFlagSet("stats", flag.ContinueOnError) // CLI command is "stats"

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'stats' command", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpSiteStatsContent) // Uses generated help
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSiteStatsContent) // Uses generated help
		return
	}

	fullURL, err := apiclient.BuildURL("/misc/stats", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /misc/stats", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /misc/stats", err)
	}

	if statusCode == http.StatusOK {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /misc/stats failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveSlowTransactionStatus corresponds to operationId: retrieveSlowTransactionStatus
func handleRetrieveSlowTransactionStatus(args []string) {
	fs := flag.NewFlagSet("retrieveSlowTransactionStatus", flag.ContinueOnError)
	transactionID := fs.String("transaction_id", "", "The transaction ID (required).") // From generated help's Arguments

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveSlowTransactionStatus' command", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveSlowTransactionStatusContent) // Uses generated help
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveSlowTransactionStatusContent) // Uses generated help
		return
	}

	if *transactionID == "" {
		fmt.Fprintln(os.Stderr, "Error: --transaction_id is required for retrieveSlowTransactionStatus.")
		utils.PrintFormattedHelp(helpRetrieveSlowTransactionStatusContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/misc/slow-transaction-status/%s", *transactionID)
	fullURL, err := apiclient.BuildURL(path, nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for transaction status", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for transaction status failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}
