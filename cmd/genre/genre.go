// cmd/genre/genre.go
package genre

import (
	"encoding/json"
	"flag"
	"fmt"
	"mangaupdatescli/internal/apiclient"
	"mangaupdatescli/internal/utils"
	"net/http"
	"os"
	"sort"
)

// CommandHandler defines the function signature for command handlers
type CommandHandler func(args []string)

// CommandInfo stores the handler and its associated (generated) help content
type CommandInfo struct {
	Handler CommandHandler
	Help    utils.HelpContent
}

// genreCommands maps the CLI command name to its handler and help
var genreCommands = make(map[string]CommandInfo)

// init populates genreCommands. The helpXxxContent variables are defined
// in the genre_generated_help.go file generated by 'go generate'.
func init() {
	// Public "read" operations for genre:
	// operationId: retrieveGenres
	// operationId: retrieveGenreById

	// Ensure helpRetrieveGenresContent is defined in genre_generated_help.go
	genreCommands["retrieveGenres"] = CommandInfo{
		Handler: handleRetrieveGenres,
		Help:    helpRetrieveGenresContent, // This var comes from the generated file
	}

	// Ensure helpRetrieveGenreByIdContent is defined in genre_generated_help.go
	genreCommands["retrieveGenreById"] = CommandInfo{
		Handler: handleRetrieveGenreById,
		Help:    helpRetrieveGenreByIdContent,
	}
}

// HandleCommand dispatches to the correct genre command handler
func HandleCommand(command string, args []string) {
	cmdInfo, ok := genreCommands[command]
	if !ok {
		isJsonHelp, _, _ := utils.CheckHelpFlags(args)
		fmt.Fprintf(os.Stderr, "Error: Unknown genre command: %s\n\n", command)
		PrintGenreSubprogramHelp(isJsonHelp)
		os.Exit(1)
	}
	cmdInfo.Handler(args)
}

// PrintGenreSubprogramHelp prints help for the entire 'genre' subprogram
func PrintGenreSubprogramHelp(jsonFormat bool) {
	if jsonFormat {
		type CommandHelpSummary struct {
			Command     string `json:"command"`
			Usage       string `json:"usage"`
			Description string `json:"description"`
		}
		var summaries []CommandHelpSummary
		var commandNames []string
		for name := range genreCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := genreCommands[name]
			summaries = append(summaries, CommandHelpSummary{
				Command:     name,
				Usage:       cmdInfo.Help.Usage,
				Description: cmdInfo.Help.Description,
			})
		}
		outputData := map[string]interface{}{
			"subprogram":  "genre",
			"description": "Commands for retrieving genre information.",
			"commands":    summaries,
		}
		jsonData, _ := json.MarshalIndent(outputData, "", "  ")
		fmt.Println(string(jsonData))
	} else {
		fmt.Println("`genre` subprogram: Commands for retrieving genre information.")
		fmt.Println("Available commands:")
		var commandNames []string
		for name := range genreCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := genreCommands[name]
			fmt.Printf("  %-30s %s\n", name, cmdInfo.Help.Description)
		}
		fmt.Println("\nUse 'mangaupdatescli genre <command> -hh' for more detailed help on a specific command.")
	}
}

// --- Handler Functions ---

// handleRetrieveGenres (GET /genres)
func handleRetrieveGenres(args []string) {
	fs := flag.NewFlagSet("retrieveGenres", flag.ContinueOnError)
	// No arguments/flags for this specific endpoint as per the spec for GET /genres

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveGenres'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveGenresContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveGenresContent)
		return
	}

	fullURL, err := apiclient.BuildURL("/genres", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /genres", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /genres", err)
	}

	if statusCode == http.StatusOK {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /genres failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody) // Print error response from API
		os.Exit(1)
	}
}

// handleRetrieveGenreById (GET /genres/{id})
func handleRetrieveGenreById(args []string) {
	fs := flag.NewFlagSet("retrieveGenreById", flag.ContinueOnError)
	genreID := fs.Int64("id", 0, "Genre ID (required).")                                                    // Path parameter: id
	unrenderedFields := fs.Bool("unrenderedFields", false, "Output fields in unrendered form for editing.") // Query parameter

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveGenreById'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveGenreByIdContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveGenreByIdContent)
		return
	}

	if *genreID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrieveGenreById.")
		utils.PrintFormattedHelp(helpRetrieveGenreByIdContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/genres/%d", *genreID)
	queryParams := make(map[string]string)
	if *unrenderedFields {
		queryParams["unrenderedFields"] = "true"
	}

	fullURL, err := apiclient.BuildURL(path, queryParams)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /genres/{id}", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /genres/{id}", err)
	}

	// Spec doesn't explicitly list 404 for GET /genres/{id}, but it's a common pattern.
	// The schema `GenreModelStatsV1` is returned on 200.
	// Assuming 404 is possible if ID doesn't exist.
	if statusCode == http.StatusOK || statusCode == http.StatusNotFound {
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /genres/{id} failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}
