// cmd/groups/groups.go
package groups

import (
	"encoding/json"
	"flag"
	"fmt"
	"mangaupdatescli/internal/apiclient"
	"mangaupdatescli/internal/utils"
	"net/http"
	"os"
	"sort"
	"strings"
)

// CommandHandler defines the function signature for command handlers
type CommandHandler func(args []string)

// CommandInfo stores the handler and its associated (generated) help content
type CommandInfo struct {
	Handler CommandHandler
	Help    utils.HelpContent
}

// groupsCommands maps the CLI command name to its handler and help
var groupsCommands = make(map[string]CommandInfo)

// init populates groupsCommands. The helpXxxContent variables are defined
// in the groups_generated_help.go file generated by 'go generate'.
func init() {
	// Public "read" operations for groups:
	// operationId: retrieveGroup
	// operationId: searchGroupsPost
	// operationId: retrieveGroupSeries

	// Ensure helpRetrieveGroupContent is defined in groups_generated_help.go
	groupsCommands["retrieveGroup"] = CommandInfo{
		Handler: handleRetrieveGroup,
		Help:    helpRetrieveGroupContent, // This var comes from the generated file
	}

	// Ensure helpSearchGroupsPostContent is defined in groups_generated_help.go
	groupsCommands["searchGroupsPost"] = CommandInfo{
		Handler: handleSearchGroupsPost,
		Help:    helpSearchGroupsPostContent,
	}

	// Ensure helpRetrieveGroupSeriesContent is defined in groups_generated_help.go
	groupsCommands["retrieveGroupSeries"] = CommandInfo{
		Handler: handleRetrieveGroupSeries,
		Help:    helpRetrieveGroupSeriesContent,
	}
}

// HandleCommand dispatches to the correct groups command handler
func HandleCommand(command string, args []string) {
	cmdInfo, ok := groupsCommands[command]
	if !ok {
		isJsonHelp, _, _ := utils.CheckHelpFlags(args)
		fmt.Fprintf(os.Stderr, "Error: Unknown groups command: %s\n\n", command)
		PrintGroupsSubprogramHelp(isJsonHelp)
		os.Exit(1)
	}
	cmdInfo.Handler(args)
}

// PrintGroupsSubprogramHelp prints help for the entire 'groups' subprogram
func PrintGroupsSubprogramHelp(jsonFormat bool) {
	if jsonFormat {
		type CommandHelpSummary struct {
			Command     string `json:"command"`
			Usage       string `json:"usage"`
			Description string `json:"description"`
		}
		var summaries []CommandHelpSummary
		var commandNames []string
		for name := range groupsCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := groupsCommands[name]
			summaries = append(summaries, CommandHelpSummary{
				Command:     name,
				Usage:       cmdInfo.Help.Usage,
				Description: cmdInfo.Help.Description,
			})
		}
		outputData := map[string]interface{}{
			"subprogram":  "groups",
			"description": "Commands for retrieving and searching scanlation group information.",
			"commands":    summaries,
		}
		jsonData, _ := json.MarshalIndent(outputData, "", "  ")
		fmt.Println(string(jsonData))
	} else {
		fmt.Println("`groups` subprogram: Commands for retrieving and searching scanlation group information.")
		fmt.Println("Available commands:")
		var commandNames []string
		for name := range groupsCommands {
			commandNames = append(commandNames, name)
		}
		sort.Strings(commandNames)

		for _, name := range commandNames {
			cmdInfo := groupsCommands[name]
			fmt.Printf("  %-30s %s\n", name, cmdInfo.Help.Description)
		}
		fmt.Println("\nUse 'mangaupdatescli groups <command> -hh' for more detailed help on a specific command.")
	}
}

// --- Handler Functions ---

// handleRetrieveGroup (GET /groups/{id})
func handleRetrieveGroup(args []string) {
	fs := flag.NewFlagSet("retrieveGroup", flag.ContinueOnError)
	groupID := fs.Int64("id", 0, "Group ID (required).")                                        // Path parameter: id
	unrenderedFields := fs.Bool("unrenderedFields", false, "Output fields in unrendered form.") // Query parameter

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveGroup'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveGroupContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveGroupContent)
		return
	}

	if *groupID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrieveGroup.")
		utils.PrintFormattedHelp(helpRetrieveGroupContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/groups/%d", *groupID)
	queryParams := make(map[string]string)
	if *unrenderedFields {
		queryParams["unrenderedFields"] = "true"
	}

	fullURL, err := apiclient.BuildURL(path, queryParams)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /groups/{id}", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /groups/{id}", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound { // 404 is an expected response
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /groups/{id} failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// Define GroupsSearchRequestV1 for the request body (from OpenAPI spec, simplified)
type GroupsSearchRequestV1 struct {
	Search  string `json:"search,omitempty"`
	AddedBy int64  `json:"added_by,omitempty"`
	Page    int    `json:"page,omitempty"`
	Perpage int    `json:"perpage,omitempty"`
	Letter  string `json:"letter,omitempty"`
	Active  *bool  `json:"active,omitempty"`  // Use pointer for optional boolean
	Pending *bool  `json:"pending,omitempty"` // Use pointer for optional boolean
}

// handleSearchGroupsPost (POST /groups/search)
func handleSearchGroupsPost(args []string) {
	fs := flag.NewFlagSet("searchGroupsPost", flag.ContinueOnError)
	var reqBody GroupsSearchRequestV1

	fs.StringVar(&reqBody.Search, "search", "", "Search term for groups.")
	addedBy := fs.Int64("added_by", 0, "Filter by user ID who added the group.")
	fs.IntVar(&reqBody.Page, "page", 0, "Page number.")
	fs.IntVar(&reqBody.Perpage, "perpage", 0, "Results per page.")
	fs.StringVar(&reqBody.Letter, "letter", "", "Filter by starting letter.")
	// For optional booleans, we need to check if the flag was set
	activeStr := fs.String("active", "", "Filter by active status (true/false). Leave empty for no filter.")
	pendingStr := fs.String("pending", "", "Filter by pending status (true/false). Leave empty for no filter.")

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'searchGroupsPost'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpSearchGroupsPostContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpSearchGroupsPostContent)
		return
	}

	// Populate struct from flags
	if *addedBy != 0 {
		reqBody.AddedBy = *addedBy
	}
	if *activeStr != "" {
		val := strings.ToLower(*activeStr) == "true"
		reqBody.Active = &val
	}
	if *pendingStr != "" {
		val := strings.ToLower(*pendingStr) == "true"
		reqBody.Pending = &val
	}

	fullURL, err := apiclient.BuildURL("/groups/search", nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /groups/search", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("POST", fullURL, reqBody)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /groups/search", err)
	}

	if statusCode == http.StatusOK { // 400 for validation error
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /groups/search failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}

// handleRetrieveGroupSeries (GET /groups/{id}/series)
func handleRetrieveGroupSeries(args []string) {
	fs := flag.NewFlagSet("retrieveGroupSeries", flag.ContinueOnError)
	groupID := fs.Int64("id", 0, "Group ID (required).") // Path parameter

	isJsonHelp, isTextHelp, remainingArgs := utils.CheckHelpFlags(args)
	if err := fs.Parse(remainingArgs); err != nil {
		utils.PrintErrorAndExit("Failed to parse flags for 'retrieveGroupSeries'", err)
	}

	if isJsonHelp {
		utils.PrintJSONHelp(helpRetrieveGroupSeriesContent)
		return
	}
	if isTextHelp {
		utils.PrintFormattedHelp(helpRetrieveGroupSeriesContent)
		return
	}

	if *groupID == 0 {
		fmt.Fprintln(os.Stderr, "Error: --id is required for retrieveGroupSeries.")
		utils.PrintFormattedHelp(helpRetrieveGroupSeriesContent)
		os.Exit(1)
	}

	path := fmt.Sprintf("/groups/%d/series", *groupID)
	fullURL, err := apiclient.BuildURL(path, nil)
	if err != nil {
		utils.PrintErrorAndExit("Failed to build URL for /groups/{id}/series", err)
	}

	respBody, statusCode, err := apiclient.DoRequest("GET", fullURL, nil)
	if err != nil {
		utils.PrintErrorAndExit("API request failed for /groups/{id}/series", err)
	}

	if statusCode == http.StatusOK || statusCode == http.StatusNotFound { // 404 if group not found
		utils.PrintJSON(respBody)
	} else {
		fmt.Fprintf(os.Stderr, "API request for /groups/{id}/series failed with status %d:\n", statusCode)
		utils.PrintJSON(respBody)
		os.Exit(1)
	}
}
